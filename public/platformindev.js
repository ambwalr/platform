// Generated by CoffeeScript 1.6.3
(function() {
  var BLOCKCREATIONTOOL, Block, BoggleParticle, BugLady, BugMeter, Cloud, ControlObj, Energy, GenericSprite, Grid, Hat, INIT, Jelly, Lila, ORIGCLICKPOS, PP, PchooParticle, PowerSuit, Sky, Sprite, Target, Thug, V, VTOPP, WORLD, WORLD_ONE_INIT, achieve, adjustmouseevent, animate, arrclone, arrowdown, arrowleft, arrowright, arrowup, arrsansval, audiobaseurl, availableactions, bglayer, bindingsDOM, blocksatpoint, body, bogglescreen, boggletitles, bogimg, bogsprite, bottomcenter, bottomof, camera, cameraoffset, cancelFullScreen, checkcolls, chievs, control, creatingblock, degstorads, down, drawhitboxes, drawsprite, entcenter, entitycount, falltitles, fglayer, fieldgoaltitles, fpscounter, hitboxfilter, hitboxlayer, initsprite, isholdingkey, k, kick, ladybug, launchFullScreen, left, leftof, load, mainloop, makebox, makechievbox, maketablerow, mousemiddledownhandler, mousemiddleuphandler, mousemovehandler, mouserightdownhandler, murdertitles, normalizekey, parentstage, pausescreen, pausetext, placeshrub, playsound, punch, randelem, randfloat, randint, randpos, randvec, relativetobox, removesprite, render, renderer, right, rightof, save, scale, screensize, settings, settingsDOM, skipframes, snapmouseadjust, sourcebaseurl, spritelayer, stage, targettitles, tex, text, tickno, ticktimes, tickwaitms, timecall, titlescreen, tmpcanvas, tmpcanvasjq, toggleFullScreen, topof, tt, up, updatesettingstable, v, xmlwrap, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  settings = {};

  settings.drawsprites = true;

  settings.slowmo = false;

  settings.altcostume = true;

  settings.beanmode = false;

  settings.muted = true;

  settings.paused = false;

  settings.volume = 0.2;

  settings.decemberween = true;

  sourcebaseurl = "./sprites/";

  audiobaseurl = "./audio/";

  body = $("body");

  V = function(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    return new V2d(x, y);
  };

  PP = function(x, y) {
    return new PIXI.Point(x, y);
  };

  VTOPP = function(v) {
    return PP(v.x, v.y);
  };

  screensize = V(64 * 10, 64 * 6);

  playsound = function(src) {
    var snd;
    if (settings.muted) {
      return;
    }
    snd = new Audio(audiobaseurl + src);
    snd.volume = settings.volume;
    return snd.play();
  };

  parentstage = new PIXI.Stage(0x66FF99);

  stage = new PIXI.DisplayObjectContainer;

  parentstage.addChild(stage);

  hitboxlayer = new PIXI.DisplayObjectContainer;

  stage.addChild(hitboxlayer);

  renderer = PIXI.autoDetectRenderer(screensize.x, screensize.y);

  pausescreen = new PIXI.Graphics();

  pausescreen.beginFill(0x000000);

  pausescreen.drawRect(0, 0, screensize.x, screensize.y);

  pausescreen.alpha = 0.5;

  pausetext = new PIXI.Text("PAUSED", {
    font: "32px Arial",
    fill: "white",
    strokeThickness: 8,
    stroke: 'red'
  });

  pausetext.position = VTOPP(screensize.ndiv(2));

  pausetext.anchor = PP(1 / 2, 1);

  pausescreen.addChild(pausetext);

  pausetext = new PIXI.Text("GO GET SOME SNACKS\nPERHAPS A CARBONATED SODA", {
    font: "16px Arial",
    fill: "white"
  });

  pausetext.position = VTOPP(screensize.ndiv(2).vadd(V(0, 64)));

  pausetext.anchor = PP(1 / 2, 0);

  pausescreen.addChild(pausetext);

  bogglescreen = new PIXI.Graphics();

  bogglescreen.beginFill(0xFF00FF);

  bogglescreen.drawRect(0, 0, screensize.x, screensize.y);

  bogglescreen.alpha = 0.5;

  tex = PIXI.Texture.fromImage(sourcebaseurl + 'bugboggle.png');

  bogsprite = new PIXI.Sprite(tex);

  bogsprite.anchor = PP(1 / 2, 1 / 2);

  bogsprite.position = VTOPP(screensize.ndiv(2));

  bogsprite.scale = PP(2, 2);

  text = new PIXI.Text("conglaturation you found a SECRET SAPPHIC SMOOCHING SCE-\nwait a minute i've been lied to\nthere are zero smooches happening", {
    font: "16px Arial",
    fill: "white"
  });

  text.position = VTOPP(screensize.ndiv(2).vadd(V(0, -128)));

  text.anchor = PP(1 / 2, 0);

  bogglescreen.addChild(text);

  bogglescreen.addChild(bogsprite);

  tex = PIXI.Texture.fromImage(sourcebaseurl + 'titleplaceholder.png');

  titlescreen = new PIXI.Sprite(tex);

  body.append(renderer.view);

  scale = 1;

  animate = function() {
    var cam;
    cam = cameraoffset().nmul(-scale);
    stage.position = VTOPP(cam);
    stage.scale = PP(scale, scale);
    renderer.render(parentstage);
    return requestAnimFrame(animate);
  };

  chievs = {};

  achieve = function(title) {
    if (chievs[title].gotten != null) {
      return;
    }
    chievs[title].gotten = true;
    console.log(chievs);
    return makechievbox(chievs[title].pic, randelem(chievs[title].text));
  };

  bogimg = xmltag('img', {
    src: sourcebaseurl + 'boggle.png'
  });

  murdertitles = ["This isn't brave, it's murder", "Jellycide"];

  fieldgoaltitles = ["3 points field goal", "Into the dunklesphere", "Blasting off again", "pow zoom straight to the moon"];

  falltitles = ["Fractured spine", "Faceplant", "Dats gotta hoit", "OW FUCK", "pomf =3", "Broken legs", "Have a nice trip", "Ow my organs", "Shattered pelvis", "Bugsplat"];

  boggletitles = ["Buggy the boggle champ", "Bushboggler 2013", "Boggle that bush", "Collosal waste of time", "Boggle 2: Electric boggleoo", "Buggy bushboggle", "excuse me wtf are you doing", "Bush it, bush it real good", "Fondly regard flora", "&lt;chievo title unavailable due to trademark infringement&gt;", "Returning a bug to its natural habitat", "Bush it to the limit", "Live Free or Boggle Hard", "Identifying bushes, accurate results with simple tools", "Bugtester", "A proper lady (bug)", "Stupid achievement title", "The daily boggle", bogimg + bogimg + bogimg];

  targettitles = ["there's no achievement for this", "\"Pow, motherfucker, pow\" -socrates", "Expect more. Pay less.", "You're supposed to use arrows you dingus"];

  chievs.fall = {
    pic: "lovelyfall.png",
    text: falltitles
  };

  chievs.kick = {
    pic: "jelly.png",
    text: fieldgoaltitles
  };

  chievs.boggle = {
    pic: "boggle.png",
    text: boggletitles
  };

  chievs.murder = {
    pic: "lovelyshorter.png",
    text: murdertitles
  };

  chievs.target = {
    pic: "target.png",
    text: targettitles
  };

  arrclone = function(arr) {
    return arr.slice(0);
  };

  arrsansval = function(arr, val) {
    var i, newarr, _ref;
    newarr = arrclone(arr);
    if (_ref = !val, __indexOf.call(arr, _ref) >= 0) {
      return newarr;
    }
    i = newarr.indexOf(val);
    newarr.splice(i, 1);
    return newarr;
  };

  randfloat = function() {
    return -1 + Math.random() * 2;
  };

  randvec = function() {
    return V(randfloat(), randfloat());
  };

  randint = function(max) {
    return Math.floor(Math.random() * max);
  };

  randelem = function(arr) {
    return arr[randint(arr.length)];
  };

  makechievbox = function(src, text) {
    var chievbox, pic;
    body.append(chievbox = $("<div class=chievbox><span style='display: inline-block; margin-left: 16px'><b>ACHIEVEMENT UNLOCKED</b><br/>" + text + "</span></div>"));
    chievbox.prepend(pic = $(xmltag('img', {
      src: sourcebaseurl + src
    })));
    chievbox.animate({
      top: '32px'
    }).delay(4000);
    return chievbox.animate({
      top: '-100px'
    }, {
      queue: true
    }).delay(2000);
  };

  GenericSprite = (function() {
    function GenericSprite(pos, src) {
      this.pos = pos != null ? pos : V();
      this.src = src;
      this.vel = V();
    }

    GenericSprite.prototype.render = function() {
      var anchor, flip, pos;
      anchor = this.anchor || V(0, 0);
      flip = false;
      pos = relativetobox(this.gethitbox(), anchor);
      return drawsprite(this, this.src, pos, flip, anchor);
    };

    return GenericSprite;

  })();

  GenericSprite.prototype.cleanup = function() {
    return removesprite(this);
  };

  Sprite = (function() {
    function Sprite() {
      this.vel = V();
      this.pos = V();
    }

    Sprite.prototype.tick = function() {};

    return Sprite;

  })();

  Hat = (function(_super) {
    __extends(Hat, _super);

    function Hat() {
      this.src = "hat.png";
      this.pos = V();
      this.anchor = V(1 / 2, 1.5);
      console.log("HAT ACQUIRED");
    }

    return Hat;

  })(GenericSprite);

  Hat.prototype.tick = function() {
    return this.pos = ladybug.pos;
  };

  GenericSprite.prototype.gethitbox = function() {
    var anchor, size;
    size = V(32, 32);
    anchor = this.anchor || V(0, 0);
    return makebox(this.pos, size, anchor);
  };

  Target = (function(_super) {
    __extends(Target, _super);

    function Target(pos) {
      this.pos = pos;
      this.src = 'target.png';
      this.lifetime = -1;
      this.vel = V();
    }

    Target.prototype.collide = function(otherent) {
      if (otherent instanceof BoggleParticle) {
        this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
      }
      if ((otherent.attacktimeout != null) && otherent.attacktimeout > 0 && topof(otherent.gethitbox()) < topof(this.gethitbox())) {
        return this.gethitby(otherent);
      }
    };

    Target.prototype.gethitby = function(otherent) {
      if (this.src !== 'shatteredtarget.png') {
        this.src = 'shatteredtarget.png';
        this.vel = otherent.vel.nmul(1 / 2);
        return this.lifetime = 10;
      }
    };

    return Target;

  })(GenericSprite);

  Jelly = (function(_super) {
    __extends(Jelly, _super);

    function Jelly(pos) {
      this.pos = pos;
      this.lifetime = -1;
      this.vel = V();
      this.src = 'jelly.png';
    }

    Jelly.prototype.collide = function(otherent) {
      if (otherent instanceof Jelly) {
        this.vel.x = (this.vel.x + otherent.vel.x) / 2;
        this.pos.x += randfloat() * 2;
      }
      if (otherent instanceof BoggleParticle) {
        this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
      }
      if (otherent instanceof BugLady && otherent.vel.y > 0) {
        otherent.vel.y *= -0.9;
      }
      if ((otherent.attacktimeout != null) && otherent.attacktimeout > 0 && topof(otherent.gethitbox()) < topof(this.gethitbox())) {
        return this.gethitby(otherent);
      }
    };

    Jelly.prototype.gethitby = function(otherent) {
      var dir;
      this.vel.y += otherent.vel.y;
      dir = otherent.facingleft ? -1 : 1;
      this.vel.x += dir * 4;
      return this.lifetime = 10;
    };

    Jelly.prototype.render = function() {
      var anchor, flip, pos;
      flip = tickno % 10 < 5;
      anchor = V(1 / 2, 1);
      pos = relativetobox(this.gethitbox(), anchor);
      return drawsprite(this, this.src, pos, flip, anchor);
    };

    return Jelly;

  })(GenericSprite);

  Jelly.prototype.gethitbox = function() {
    return makebox(this.pos, V(32, 16), bottomcenter);
  };

  degstorads = function(degs) {
    return degs * Math.PI / 180;
  };

  GenericSprite.prototype.touchingground = function() {
    var block, blockcandidates, collidebox, touch, _i, _len;
    touch = false;
    collidebox = this.gethitbox();
    blockcandidates = bglayer.filter(function(block) {
      return collidebox.overlaps(block);
    });
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      if (collidebox.y + collidebox.h < block.y + block.h) {
        touch = true;
      }
    }
    return touch;
  };

  entitycount = function(classtype) {
    var ents;
    ents = spritelayer.filter(function(sprite) {
      return sprite instanceof classtype;
    });
    return ents.length;
  };

  Jelly.prototype.tick = function() {
    this.avoidwalls();
    if (this.pos.y < 0) {
      achieve("kick");
    }
    if (this.pos.y < 0 || this.pos.y > 640) {
      this.KILLME = true;
      if (entitycount(Jelly) === 1) {
        achieve("murder");
      }
    }
    if (this.touchingground()) {
      this.vel.y = 0;
      this.pos.y--;
      this.jiggle();
    }
    this.gravitate();
    return this.pos = this.pos.vadd(this.vel);
  };

  Jelly.prototype.jiggle = function() {
    this.vel.x *= 9 / 10;
    if (Math.random() * 100 < 50) {
      this.vel.y = -Math.random() * 4;
      return this.vel.x += randfloat() * 1;
    }
  };

  GenericSprite.prototype.gravitate = function() {
    if (!this.touchingground()) {
      return this.vel.y++;
    }
  };

  Energy = (function(_super) {
    __extends(Energy, _super);

    function Energy(pos) {
      this.pos = pos;
      this.vel = V();
      this.src = "energy1.png";
    }

    return Energy;

  })(Jelly);

  Energy.prototype.getsprite = function() {
    var framechoice, framelist, framewait, totalframes;
    framelist = [1, 2, 3, 4, 5, 6].map(function(n) {
      return "energy" + n + ".png";
    });
    totalframes = framelist.length;
    framewait = 4;
    framechoice = Math.floor(tickno / framewait) % totalframes;
    return this.src = framelist[framechoice];
  };

  Energy.prototype.tick = function() {
    Energy.__super__.tick.call(this);
    return this.getsprite();
  };

  Energy.prototype.jiggle = function() {};

  relativetobox = function(box, anchor) {
    var pos, size;
    pos = V(box.x, box.y);
    size = V(box.w, box.h);
    pos = pos.vadd(size.vmul(anchor));
    return pos;
  };

  Thug = (function(_super) {
    __extends(Thug, _super);

    function Thug(pos) {
      this.pos = pos;
      this.lifetime = -1;
      this.vel = V();
      this.src = 'bugthug.png';
      this.facingleft = true;
    }

    Thug.prototype.render = function() {
      var anchor, box, flip, pos, sprit;
      flip = !this.facingleft;
      box = this.gethitbox();
      anchor = V(1 / 2, 1);
      pos = relativetobox(box, anchor);
      return sprit = drawsprite(this, this.src, pos, flip, anchor);
    };

    return Thug;

  })(GenericSprite);

  bottomcenter = V(1 / 2, 1);

  Thug.prototype.gethitbox = function() {
    return makebox(this.pos, V(24, 64), bottomcenter);
  };

  Thug.prototype.tick = function() {
    this.pos = this.pos.vadd(this.vel);
    this.avoidwalls();
    this.blockcollisions();
    if (this.touchingground()) {
      this.pos.y--;
      this.vel.y = 0;
      this.friction();
    }
    this.gravitate();
    return this.getsprite();
  };

  Thug.prototype.getsprite = function() {
    if (this.lifetime <= 0) {
      this.src = 'bugthug.png';
    }
    if (this.lifetime > 0) {
      this.lifetime--;
      return this.src = "bugthugoof.png";
    }
  };

  Thug.prototype.collide = function(otherent) {
    if (otherent instanceof BoggleParticle) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
    }
    if ((otherent.attacktimeout != null) && otherent.attacktimeout > 0) {
      return this.gethitby(otherent);
    }
  };

  Thug.prototype.gethitby = function(otherent) {
    var dir;
    this.vel.y += otherent.vel.y;
    dir = otherent.facingleft ? -1 : 1;
    this.vel.x += dir * 1;
    return this.lifetime = 10;
  };

  Lila = (function(_super) {
    __extends(Lila, _super);

    function Lila() {
      _ref = Lila.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return Lila;

  })(Thug);

  Lila.prototype.tick = function() {
    var vel;
    Lila.__super__.tick.call(this);
    if (!this.scampering && Math.random() < 1 / 10) {
      this.scampering = true;
    }
    if (this.scampering && Math.random() < 1 / 10) {
      this.scampering = false;
    }
    if (this.scampering) {
      vel = this.facingleft ? -1 : 1;
      this.pos.x += vel;
    }
    if (!this.scampering && Math.random() < 1 / 20) {
      return this.facingleft = !this.facingleft;
    }
  };

  Lila.prototype.getsprite = function() {
    var framechoice, framelist, framewait, idlecycle, scampercycle, totalframes;
    idlecycle = ['lilaidle1.png', 'lilaidle2.png'];
    scampercycle = [1, 2, 3, 4].map(function(n) {
      return "lilascamper" + n + ".png";
    });
    framelist = idlecycle;
    if (this.scampering) {
      framelist = scampercycle;
    }
    totalframes = framelist.length;
    framewait = 4;
    framechoice = Math.floor(tickno / framewait) % totalframes;
    return this.src = framelist[framechoice];
  };

  Lila.prototype.collide = function(otherent) {
    if (otherent instanceof BoggleParticle) {
      return parentstage.addChild(bogglescreen);
    }
  };

  GenericSprite.prototype.blockcollisions = function() {
    var box, candidates, spriteheight,
      _this = this;
    box = this.gethitbox();
    spriteheight = box.h;
    candidates = hitboxfilter(box, bglayer);
    candidates.forEach(function(candidate) {
      if (bottomof(_this.gethitbox()) >= topof(candidate)) {
        _this.pos.y = candidate.y;
        return _this.vel.y = 0;
      }
    });
    if (candidates.length > 0 && this.vel.y < 0) {
      return this.vel.y = 0;
    }
  };

  BoggleParticle = (function(_super) {
    __extends(BoggleParticle, _super);

    function BoggleParticle(pos) {
      this.pos = pos != null ? pos : V();
      this.pos = this.pos.nadd(-8);
      this.pos.y += 16;
      this.vel = randvec().norm();
      this.src = 'huh.png';
      this.life = 50;
    }

    BoggleParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(randvec().norm().ndiv(8));
    };

    return BoggleParticle;

  })(GenericSprite);

  BoggleParticle.prototype.render = function() {
    return drawsprite(this, 'huh.png', this.pos, false);
  };

  PchooParticle = (function(_super) {
    __extends(PchooParticle, _super);

    function PchooParticle(pos) {
      this.pos = pos != null ? pos : V();
      this.vel = randvec().norm().ndiv(8);
      this.life = 20;
      this.src = 'bughealth.png';
      this.anchor = V(1 / 2, 1 / 2);
    }

    PchooParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(randvec().norm().ndiv(64));
    };

    PchooParticle.prototype.render = function() {
      drawsprite(this, this.src, this.pos, false, this.anchor);
      return this._pixisprite.alpha = 0.25;
    };

    return PchooParticle;

  })(GenericSprite);

  Target.prototype.tick = function() {
    this.vel = this.vel || V(0, 0);
    this.vel = this.vel.nmul(7 / 10);
    this.pos = this.pos.vadd(this.vel);
    if (this.lifetime === 0) {
      this.KILLME = true;
    }
    if (this.lifetime > 0) {
      this.lifetime--;
    }
    if (this.lifetime === 0 && entitycount(Target) === 1) {
      return achieve("target");
    }
  };

  isholdingkey = function(key) {
    key = key.toUpperCase().charCodeAt(0);
    return __indexOf.call(control.heldkeys, key) >= 0;
  };

  BugLady = (function(_super) {
    __extends(BugLady, _super);

    function BugLady() {
      BugLady.__super__.constructor.apply(this, arguments);
      this.jumping = false;
      this.attacking = false;
      this.attacktimeout = 0;
      this.stuntimeout = 0;
      this.health = 3;
    }

    return BugLady;

  })(GenericSprite);

  BugLady.prototype.respawn = function() {
    this.pos = V();
    this.vel = V();
    return this.health = 3;
  };

  BugLady.prototype.takedamage = function() {
    this.health -= 1;
    if (this.health <= 0) {
      return this.kill();
    }
  };

  entcenter = function(ent) {
    var hb;
    hb = ent.gethitbox();
    return V(hb.x + hb.w / 2, hb.y + hb.h / 2);
  };

  BugLady.prototype.blockcollisions = function() {
    var box, candidates, spriteheight,
      _this = this;
    spriteheight = 64;
    box = this.fallbox();
    candidates = hitboxfilter(box, bglayer);
    candidates.forEach(function(candidate) {
      if (bottomof(_this.gethitbox()) <= topof(candidate)) {
        if (_this.vel.y > 20) {
          _this.stuntimeout = 20;
          _this.takedamage();
        }
        _this.pos.y = candidate.y;
        return _this.vel.y = 0;
      }
    });
    if (candidates.length > 0 && this.vel.y < 0) {
      return this.vel.y = 0;
    }
  };

  BugLady.prototype.checkcontrols = function() {
    this.holdingboggle = isholdingkey('x');
    return this.holdingjump = isholdingkey('w');
  };

  BugLady.prototype.cancelattack = function() {
    this.attacktimeout = 0;
    return this.attacking = false;
  };

  BugLady.prototype.outofbounds = function() {
    return this.pos.y > 640;
  };

  BugLady.prototype.kill = function() {
    if (this.ded) {
      $('#deathmsg').html("<b>WHAT DID I JUST TELL YOU</b>");
    }
    if (!this.ded) {
      body.prepend("<p id=deathmsg><b>YOU'RE DEAD</b> now don't let me catch you doing that again young lady</p>");
      this.ded = true;
    }
    return this.respawn();
  };

  BugLady.prototype.tick = function() {
    var boggling, heading, jumpvel, unpowered, vel, vellimit, walking;
    unpowered = settings.altcostume;
    if (unpowered) {
      this.cancelattack();
    }
    this.checkcontrols();
    if (this.outofbounds()) {
      this.kill();
    }
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    boggling = !walking && this.touchingground() && this.holdingboggle;
    if (boggling && Math.random() < 0.3) {
      this.boggle();
    }
    if (this.poweruptimeout > 0) {
      this.poweruptimeout--;
      this.vel = V2d.zero();
    }
    if (this.stuntimeout > 0) {
      this.stuntimeout--;
      achieve("fall");
      this.vel = V2d.zero();
    }
    vellimit = this.touchingground() ? 4 : 5;
    this.vel.x = mafs.clamp(this.vel.x, -vellimit, vellimit);
    this.blockcollisions();
    this.avoidwalls();
    this.attacking = this.attacktimeout > 0;
    heading = this.facingleft ? -1 : 1;
    if (this.attacking) {
      this.vel.y *= 0.7;
      this.attacktimeout -= 1;
      this.vel.x += heading * 0.3;
      spritelayer.push(new PchooParticle(entcenter(this)));
    }
    if (this.attacking && this.punching && this.touchingground()) {
      this.vel.x = this.vel.x * 0.1;
    }
    this.pos = this.pos.vadd(this.vel);
    if (!this.touchingground()) {
      this.gravitate();
      if (!this.holdingjump && this.vel.y < 0) {
        this.vel.y /= 2;
      }
    }
    if (this.touchingground()) {
      this.friction();
    }
    jumpvel = unpowered ? 12 : 16;
    this.jumpimpulse(jumpvel);
    this.jumping = false;
    return this.climbing = this.touchingwall();
  };

  BugLady.prototype.jumpimpulse = function(jumpvel) {
    if (this.touchingground() && this.jumping) {
      return this.vel.y = -jumpvel;
    }
  };

  BugLady.prototype.gravitate = function() {
    return this.vel.y += 1;
  };

  GenericSprite.prototype.friction = function() {
    this.vel.x = this.vel.x * 0.5;
    if (Math.abs(this.vel.x) < 0.0001) {
      return this.vel.x = 0;
    }
  };

  BugLady.prototype.boggle = function() {
    var boxes, cand, hit;
    spritelayer.push(new BoggleParticle(entcenter(this)));
    hit = ladybug.gethitbox();
    boxes = fglayer.map(function(obj) {
      return obj.gethitbox();
    });
    cand = hitboxfilter(hit, boxes);
    if (cand.length > 0) {
      return achieve("boggle");
    }
  };

  BugLady.prototype.getsprite = function() {
    var src, vel, walking;
    if (settings.beanmode) {
      return "bugbean.png";
    }
    src = "lovelyshorter.png";
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    if (walking) {
      src = tickno % 12 > 6 ? 'lovelyrun1.png' : 'lovelyrun2.png';
    }
    if (!this.touchingground()) {
      src = this.vel.y < 0 ? 'lovelyjump.png' : 'lovelycrouch.png';
    }
    if (!walking && isholdingkey('s')) {
      src = 'lovelycrouch.png';
    }
    if (!walking && this.touchingground() && this.holdingboggle) {
      src = 'boggle.png';
    }
    if (this.attacking) {
      src = 'viewtiful.png';
    }
    if (this.attacking && this.punching) {
      src = 'bugpunch.png';
    }
    if (this.attacking && this.attacktimeout < 2 && this.punching) {
      src = 'lovelyrun2.png';
    }
    if (this.attacking && this.kicking) {
      src = 'bugkick.png';
    }
    if (this.stuntimeout > 0) {
      src = 'lovelycrouch.png';
    }
    if (this.stuntimeout > 4) {
      src = 'lovelyfall.png';
    }
    if (this.poweruptimeout > 0) {
      src = 'viewtiful.png';
    }
    if (this.poweruptimeout > 16) {
      src = 'boggle.png';
      this.facingleft = this.poweruptimeout % 10 < 5;
    }
    if (this.poweruptimeout > 32) {
      src = 'marl/boggle.png';
    }
    if (settings.altcostume) {
      src = "marl/" + src;
    }
    if (this.climbing) {
      src = 'bugclimb1.png';
    }
    return src;
  };

  BugLady.prototype.render = function() {
    var anchor, flip, offs, pos, sprit, src, vel, walking;
    vel = Math.abs(this.vel.x);
    walking = vel > 1;
    src = this.getsprite();
    flip = this.facingleft;
    if (settings.beanmode && walking) {
      flip = tickno % 8 < 4;
    }
    offs = V(0, 4);
    anchor = V(1 / 2, 1);
    pos = relativetobox(this.gethitbox(), anchor);
    pos = offs.vadd(pos);
    sprit = drawsprite(this, src, pos, flip, anchor);
    if (src === 'boggle.png') {
      return sprit.rotation = degstorads(randfloat() * 4);
    } else {
      return sprit.rotation = 0;
    }
  };

  removesprite = function(ent) {
    if (!ent._pixisprite) {
      return;
    }
    return stage.removeChild(ent._pixisprite);
  };

  initsprite = function(ent, tex) {
    var sprit;
    sprit = new PIXI.Sprite(tex);
    ent._pixisprite = sprit;
    stage.addChild(sprit);
    return sprit;
  };

  drawsprite = function(ent, src, pos, flip, anchor) {
    var sprit;
    if (anchor == null) {
      anchor = V();
    }
    tex = PIXI.Texture.fromImage(sourcebaseurl + src);
    if (!ent._pixisprite) {
      initsprite(ent, tex);
    }
    sprit = ent._pixisprite;
    sprit.position = VTOPP(pos);
    sprit.anchor = VTOPP(anchor);
    sprit.setTexture(tex);
    sprit.scale.x = flip ? -1 : 1;
    return sprit;
  };

  Block = (function() {
    function Block(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.pos = V(this.x, this.y);
    }

    return Block;

  })();

  Block.prototype.overlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.x > rectb.x + rectb.w || recta.y > rectb.y + rectb.h || recta.x + recta.w < rectb.x || recta.y + recta.h < rectb.y) {
      return false;
    } else {
      return true;
    }
  };

  hitboxfilter = function(hitbox, rectarray) {
    return rectarray.filter(function(box) {
      return hitbox.overlaps(box);
    });
  };

  makebox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return new Block(truepos.x, truepos.y, dimensions.x, dimensions.y);
  };

  bottomcenter = V(1 / 2, 1);

  BugLady.prototype.gethitbox = function() {
    var h, w;
    w = 16;
    h = 32;
    return makebox(this.pos, V(w, h), bottomcenter);
  };

  BugLady.prototype.fallbox = function() {
    var box;
    box = this.gethitbox();
    box.y += this.vel.y;
    box.x += this.vel.x;
    return box;
  };

  leftof = function(box) {
    return box.x;
  };

  rightof = function(box) {
    return box.x + box.w;
  };

  bottomof = function(box) {
    return box.y + box.h;
  };

  topof = function(box) {
    return box.y;
  };

  Block.prototype.left = function() {
    return leftof(this);
  };

  Block.prototype.right = function() {
    return rightof(this);
  };

  Block.prototype.bottom = function() {
    return bottomof(this);
  };

  Block.prototype.top = function() {
    return topof(this);
  };

  blocksatpoint = function(blocks, p) {
    return blocks.filter(function(box) {
      return box.x <= p.x && box.y <= p.y && box.x + box.w >= p.x && box.y + box.h >= p.y;
    });
  };

  GenericSprite.prototype.touchingwall = Sprite.prototype.touchingwall = function() {
    var block, blockcandidates, collidebox, notontop, _i, _len;
    collidebox = this.gethitbox();
    blockcandidates = hitboxfilter(collidebox, bglayer);
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      notontop = bottomof(collidebox) > topof(block);
      if (notontop && collidebox.left() < block.left()) {
        return true;
      }
      if (notontop && collidebox.right() > block.right()) {
        return true;
      }
    }
    return false;
  };

  GenericSprite.prototype.avoidwalls = Sprite.prototype.avoidwalls = function() {
    var block, blockcandidates, collidebox, notontop, ofs, _i, _len, _results;
    collidebox = this.gethitbox();
    blockcandidates = hitboxfilter(collidebox, bglayer);
    _results = [];
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      notontop = bottomof(collidebox) > topof(block);
      ofs = 1;
      if (notontop && leftof(collidebox) < leftof(block)) {
        this.vel.x = 0;
        this.pos.x -= ofs;
      }
      if (notontop && rightof(collidebox) > rightof(block)) {
        this.vel.x = 0;
        _results.push(this.pos.x += ofs);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  BugLady.prototype.touchingground = function() {
    var block, blockcandidates, collidebox, touch, _i, _len;
    touch = false;
    collidebox = this.gethitbox();
    blockcandidates = hitboxfilter(collidebox, bglayer);
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      if (bottomof(collidebox) < bottomof(block)) {
        touch = true;
      }
    }
    return touch;
  };

  PowerSuit = (function(_super) {
    __extends(PowerSuit, _super);

    function PowerSuit(pos) {
      this.pos = pos;
      PowerSuit.__super__.constructor.call(this, this.pos, 'suit.png');
    }

    return PowerSuit;

  })(GenericSprite);

  PowerSuit.prototype.collide = function(otherent) {
    if (otherent instanceof BugLady) {
      this.KILLME = true;
      otherent.poweruptimeout = 45;
      return settings.altcostume = false;
    }
  };

  ControlObj = (function() {
    function ControlObj() {
      this.bindings = {};
      this.holdbindings = {};
      this.heldkeys = [];
      this.bindingnames = {};
    }

    return ControlObj;

  })();

  control = new ControlObj;

  this.control = control;

  normalizekey = function(key) {
    return key.toUpperCase().charCodeAt(0);
  };

  ControlObj.prototype.keytapbindraw = function(key, func) {
    return this.bindings[key] = func;
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return this.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keytapbindname = function(key, name, func) {
    this.bindingnames[normalizekey(key)] = name;
    console.log(this.bindingnames);
    return this.keytapbind(key, func);
  };

  ControlObj.prototype.keyBindRawNamed = function(key, name, func) {
    this.bindingnames[key] = name;
    console.log(this.bindingnames);
    return this.keytapbindraw(key, func);
  };

  ControlObj.prototype.keyholdbind = function(key, func) {
    return this.holdbindings[normalizekey(key)] = func;
  };

  control.keytapbindname('9', 'zoom out', function() {
    return scale -= 0.1;
  });

  control.keytapbindname('0', 'zoom in', function() {
    return scale += 0.1;
  });

  launchFullScreen = function(elm) {
    if (typeof elm.requestFullScreen === "function") {
      elm.requestFullScreen();
    }
    if (typeof elm.mozRequestFullScreen === "function") {
      elm.mozRequestFullScreen();
    }
    return typeof elm.webkitRequestFullScreen === "function" ? elm.webkitRequestFullScreen() : void 0;
  };

  cancelFullScreen = function() {
    if (typeof document.cancelFullScreen === "function") {
      document.cancelFullScreen();
    }
    if (typeof document.mozCancelFullScreen === "function") {
      document.mozCancelFullScreen();
    }
    return typeof document.webkitCancelFullScreen === "function" ? document.webkitCancelFullScreen() : void 0;
  };

  toggleFullScreen = function(elm) {
    var isfullscreen;
    isfullscreen = document.fullScreen || document.mozFullScreen || document.webkitFullScreen;
    if (isfullscreen) {
      return cancelFullScreen();
    } else {
      return launchFullScreen(elm);
    }
  };

  control.keytapbindname('y', 'toggle fullscreen', function() {
    return toggleFullScreen(renderer.view);
  });

  control.keytapbindname('p', 'pause', function() {
    playsound("pause.wav");
    settings.paused = !settings.paused;
    if (settings.paused) {
      parentstage.addChild(pausescreen);
    }
    if (!settings.paused) {
      return parentstage.removeChild(pausescreen);
    }
  });

  control.keytapbindname('t', 'underclock/slowmo', function() {
    return settings.slowmo = !settings.slowmo;
  });

  control.keytapbindname('g', 'toggle grid', function() {
    return settings.grid = !settings.grid;
  });

  control.keytapbindname('b', 'toggle beanmode', function() {
    return settings.beanmode = !settings.beanmode;
  });

  control.keytapbindname('l', 'WHAM!', function() {
    ladybug.jumping = true;
    ladybug.kicking = false;
    return ladybug.punching = false;
  });

  control.keyholdbind('l', function() {
    return ladybug.attacktimeout = 10;
  });

  punch = function() {
    ladybug.punching = true;
    ladybug.kicking = false;
    ladybug.attacktimeout = 10;
    return playsound("hit.wav");
  };

  kick = function() {
    ladybug.kicking = true;
    ladybug.jumping = true;
    ladybug.punching = false;
    ladybug.attacktimeout = 10;
    return playsound("hit.wav");
  };

  control.keytapbindname('j', 'POW!', punch);

  control.keytapbindname('k', 'BAM!', kick);

  control.keytapbindname('m', 'mute', function() {
    return settings.muted = !settings.muted;
  });

  up = function() {
    if (ladybug.touchingground()) {
      playsound("jump.wav");
    }
    return ladybug.jumping = true;
  };

  down = function() {};

  left = function() {
    var amt;
    ladybug.facingleft = true;
    amt = ladybug.touchingground() ? 3 : 1;
    return ladybug.vel.x -= amt;
  };

  right = function() {
    var amt;
    ladybug.facingleft = false;
    amt = ladybug.touchingground() ? 3 : 1;
    return ladybug.vel.x += amt;
  };

  availableactions = [up, down, left, right];

  control.keyholdbind('w', up);

  control.keyholdbind('s', down);

  control.keyholdbind('a', left);

  control.keyholdbind('d', right);

  arrowleft = 37;

  arrowup = 38;

  arrowright = 39;

  arrowdown = 40;

  control.keyBindRawNamed(arrowup, 'jump', up);

  save = function() {
    var tmpladybug;
    console.log(ladybug);
    tmpladybug = $.extend({}, ladybug);
    tmpladybug._pixisprite = void 0;
    console.log("saving");
    localStorage["bug"] = JSON.stringify(tmpladybug);
    console.log(localStorage["bug"]);
    return localStorage["settings"] = JSON.stringify(settings);
  };

  load = function() {
    console.log("loading");
    $.extend(ladybug, JSON.parse(localStorage["bug"]));
    ladybug.pos = $.extend(V(), ladybug.pos);
    ladybug.vel = V(ladybug.vel.x, ladybug.vel.y);
    return $.extend(settings, JSON.parse(localStorage["settings"]));
  };

  control.keytapbindname('6', 'save', save);

  control.keytapbindname('7', 'load', load);

  this.CONTROL = control;

  $(document).bind('keydown', function(e) {
    var key, _base;
    key = e.which;
    if (typeof (_base = control.bindings)[key] === "function") {
      _base[key]();
    }
    if (!(__indexOf.call(control.heldkeys, key) >= 0)) {
      return control.heldkeys.push(key);
    }
  });

  $(document).bind('keyup', function(e) {
    var key;
    key = e.which;
    return control.heldkeys = arrsansval(control.heldkeys, key);
  });

  tmpcanvasjq = $("<canvas>");

  tmpcanvas = tmpcanvasjq[0];

  tickno = 0;

  Block.prototype.gethitbox = function() {
    return this;
  };

  Block.prototype.render = function() {
    var ent, pos, sprit, src;
    ent = this;
    src = "groundtile.png";
    pos = this.pos;
    tex = PIXI.Texture.fromImage(sourcebaseurl + src);
    if (!ent._pixisprite) {
      sprit = new PIXI.TilingSprite(tex, this.w, this.h);
      ent._pixisprite = sprit;
      stage.addChild(sprit);
    }
    sprit = ent._pixisprite;
    sprit.tilePosition.x = -this.x;
    sprit.tilePosition.y = -this.y;
    sprit.position.x = this.x;
    return sprit.position.y = this.y;
  };

  ladybug = new BugLady;

  ladybug.facingleft = false;

  ladybug.jumping = false;

  ladybug.pos = V(64, 128 + 64);

  bglayer = [];

  bglayer.push(new Block(-64, 64 * 5 - 4, 64 * 12, 100));

  bglayer.push(new Block(64 * 4, 64 * 2, 32, 32));

  bglayer.push(new Block(64 * 5, 64 * 4, 32, 32));

  bglayer.push(new Block(64 * 6, 64 * 3, 32, 32));

  bglayer.push(new Block(32, 64 * 4, 64 * 2, 64 * 2));

  bglayer.push(new Block(64 * 12, 64 * 4, 64 * 12, 200));

  fglayer = [];

  spritelayer = [];

  Sky = (function() {
    function Sky() {}

    return Sky;

  })();

  Sky.prototype.render = function() {};

  Cloud = (function(_super) {
    __extends(Cloud, _super);

    function Cloud() {
      Cloud.__super__.constructor.call(this);
      this.src = 'cloud.png';
      if (settings.decemberween) {
        this.src = 'snow.png';
      }
    }

    return Cloud;

  })(Sprite);

  Cloud.prototype.spriteinit = function() {
    var sprit;
    tex = PIXI.Texture.fromImage(sourcebaseurl + this.src);
    sprit = new PIXI.TilingSprite(tex, screensize.x, screensize.y);
    this._pixisprite = sprit;
    stage.addChildAt(sprit, 0);
    return sprit;
  };

  Cloud.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    if (!this._pixisprite) {
      this.spriteinit();
    }
    sprit = this._pixisprite;
    offset = V(tickno * -0.2, Math.sin(tickno / 200) * 64);
    sprit.position = VTOPP(pos);
    return sprit.tilePosition = VTOPP(offset);
  };

  Grid = (function(_super) {
    __extends(Grid, _super);

    function Grid() {
      Grid.__super__.constructor.call(this);
      this.src = 'square.png';
    }

    return Grid;

  })(Sprite);

  Grid.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    tex = PIXI.Texture.fromImage(sourcebaseurl + this.src);
    if (!this._pixisprite) {
      sprit = new PIXI.TilingSprite(tex, screensize.x, screensize.y);
      this._pixisprite = sprit;
      stage.addChildAt(sprit, 1);
    }
    sprit = this._pixisprite;
    offset = V(tickno * -0.2, Math.sin(tickno / 200) * 64);
    sprit.position = new PIXI.Point(pos.x, pos.y);
    offset = camera.pos.nmul(-1);
    sprit.tilePosition = new PIXI.Point(offset.x, offset.y);
    sprit.setTexture(tex);
    if (!settings.grid && this._pixisprite) {
      stage.removeChild(this._pixisprite);
      return this._pixisprite = void 0;
    }
  };

  WORLD = {};

  WORLD.entities = [];

  WORLD.entities.push(new Cloud());

  WORLD.entities.push(new Grid());

  WORLD.bglayer = bglayer;

  WORLD.fglayer = fglayer;

  WORLD.spritelayer = spritelayer;

  randpos = function() {
    return V(640 * 1.5, 64 * 2).vadd(randvec().vmul(V(640, 100)));
  };

  placeshrub = function(pos) {
    pos = pos.vsub(V(0, 32));
    return fglayer.push(new GenericSprite(pos, 'shrub.png'));
  };

  BugMeter = (function(_super) {
    __extends(BugMeter, _super);

    function BugMeter() {
      BugMeter.__super__.constructor.call(this);
      this.src = 'bughealth.png';
      this.value = 3;
    }

    return BugMeter;

  })(GenericSprite);

  BugMeter.prototype.spriteinit = function() {
    var sprit;
    tex = PIXI.Texture.fromImage(sourcebaseurl + this.src);
    this.spritesize = V(32, 32);
    sprit = new PIXI.TilingSprite(tex, this.spritesize.x, this.spritesize.y);
    this._pixisprite = sprit;
    stage.addChild(sprit);
    return sprit;
  };

  BugMeter.prototype.render = function() {
    var flip, pos, sprit;
    pos = cameraoffset();
    flip = false;
    if (!this._pixisprite) {
      this.spriteinit();
    }
    sprit = this._pixisprite;
    sprit.width = this.spritesize.x * this.value;
    return sprit.position = VTOPP(pos);
  };

  BugMeter.prototype.tick = function() {
    return this.update(ladybug.health);
  };

  BugMeter.prototype.update = function(value) {
    return this.value = value;
  };

  WORLD_ONE_INIT = function() {
    var bugmeter;
    spritelayer = spritelayer.concat([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(function() {
      return new Target(randpos());
    }));
    spritelayer = spritelayer.concat([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(function() {
      return new Jelly(randpos());
    }));
    spritelayer = spritelayer.concat([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(function() {
      return new Energy(randpos());
    }));
    spritelayer = spritelayer.concat([0, 1, 2, 3].map(function() {
      return new Thug(randpos());
    }));
    spritelayer = spritelayer.concat([0].map(function() {
      return new Lila(randpos());
    }));
    spritelayer.push(new PowerSuit(V(128, 32)));
    bglayer.push(new Block(128 + 8, 64 + 20, 64, 32));
    bglayer.push(new Block(128 + 8 + 64, 64 + 20 + 32, 32, 32));
    placeshrub(V(64 * 8, 64 * 5 - 4));
    placeshrub(V(64 * 7 - 48, 64 * 5 - 4));
    placeshrub(V(64 * 9, 64 * 5 - 4));
    bugmeter = new BugMeter;
    WORLD.entities.push(bugmeter);
    this.bugmeter = bugmeter;
    if (settings.decemberween) {
      return WORLD.entities.push(new Hat());
    }
  };

  WORLD_ONE_INIT();

  camera = {};

  camera.offset = V();

  camera.pos = V();

  PIXI.DisplayObjectContainer;

  cameraoffset = function() {
    var tmppos;
    tmppos = ladybug.pos.nadd(64).vsub(screensize.ndiv(2));
    tmppos.y = mafs.clamp(tmppos.y, -screensize.y, 0);
    return tmppos.vsub(camera.offset.ndiv(scale));
  };

  render = function() {
    var renderables;
    camera.pos = cameraoffset();
    renderables = [].concat(WORLD.bglayer, spritelayer, [ladybug], fglayer);
    renderables.forEach(function(sprite) {
      return typeof sprite.render === "function" ? sprite.render() : void 0;
    });
    WORLD.entities.forEach(function(ent) {
      return typeof ent.render === "function" ? ent.render() : void 0;
    });
    return drawhitboxes(renderables);
  };

  drawhitboxes = function(ents) {
    var graf;
    stage.removeChild(hitboxlayer);
    hitboxlayer = new PIXI.DisplayObjectContainer;
    stage.addChild(hitboxlayer);
    if (!settings.grid) {
      return;
    }
    graf = new PIXI.Graphics();
    graf.lineStyle(1, 0x00ff00, 1);
    graf.beginFill(0xff0000, 1 / 8);
    ents.forEach(function(ent) {
      var box;
      graf.drawCircle(ent.pos.x, ent.pos.y, 4);
      box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
      return graf.drawRect(box.x, box.y, box.w, box.h);
    });
    return hitboxlayer.addChild(graf);
  };

  timecall = function(func) {
    var starttime;
    starttime = Date.now();
    func();
    return Date.now() - starttime;
  };

  tickwaitms = 20;

  skipframes = 0;

  ticktimes = [];

  checkcolls = function(ent, otherents) {
    var bawks;
    bawks = ent.gethitbox();
    return otherents.forEach(function(target) {
      var targethitbox;
      if (target === ent) {
        return;
      }
      targethitbox = target.gethitbox();
      if (bawks.overlaps(targethitbox)) {
        return typeof target.collide === "function" ? target.collide(ent) : void 0;
      }
    });
  };

  WORLD.euthanasia = function() {
    var doomedsprites;
    doomedsprites = spritelayer.filter(function(sprite) {
      return sprite.KILLME != null;
    });
    return doomedsprites.forEach(function(sprite) {
      if (typeof sprite.cleanup === "function") {
        sprite.cleanup();
      }
      return spritelayer = arrsansval(spritelayer, sprite);
    });
  };

  WORLD.tick = function() {
    var key, _base, _i, _len, _ref1;
    _ref1 = control.heldkeys;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      key = _ref1[_i];
      if (typeof (_base = control.holdbindings)[key] === "function") {
        _base[key]();
      }
    }
    checkcolls(ladybug, spritelayer);
    spritelayer.forEach(function(sprite) {
      return checkcolls(sprite, arrsansval(spritelayer, sprite));
    });
    WORLD.euthanasia();
    spritelayer.forEach(function(sprite) {
      return typeof sprite.tick === "function" ? sprite.tick() : void 0;
    });
    ladybug.tick();
    WORLD.entities.forEach(function(ent) {
      return typeof ent.tick === "function" ? ent.tick() : void 0;
    });
    render();
    return tickno++;
  };

  fpscounter = $(xmltag());

  tt = 0;

  mainloop = function() {
    var fps, idealfps, ticktime;
    updatesettingstable();
    if (!settings.paused) {
      ticktime = timecall(WORLD.tick);
      tt = ticktime;
      fps = Math.round(1000 / Math.max(tickwaitms, ticktime));
      idealfps = Math.round(1000 / tickwaitms);
      fpscounter.html("tick time: " + tt + "ms, running at approx " + fps + " fps (aiming for " + idealfps + " fps)");
    }
    tickwaitms = settings.slowmo ? 1000 / 4 : 1000 / 50;
    return setTimeout(mainloop, Math.max(tickwaitms - ticktime, 1));
  };

  xmlwrap = function(tagname, body) {
    return xmltag(tagname, void 0, body);
  };

  maketablerow = function(values) {
    var tds;
    tds = values.map(function(v) {
      return xmlwrap("td", v);
    });
    return xmlwrap("tr", tds);
  };

  bindingsDOM = $("<table>");

  _ref1 = control.bindings;
  for (k in _ref1) {
    v = _ref1[k];
    bindingsDOM.append(maketablerow([keyCodeToChar[k], control.bindingnames[k] || "??"]));
  }

  settingsDOM = $("<table>");

  updatesettingstable = function() {
    var _results;
    settingsDOM.html("");
    _results = [];
    for (k in settings) {
      v = settings[k];
      _results.push(settingsDOM.append(maketablerow([k, v])));
    }
    return _results;
  };

  INIT = function() {
    body.append("<br/><em>there's no crime to fight around here, use WASD to waste time by purposelessly wiggling around,<br/>X to boggle vacantly and JKL to do some wicked sick totally radical moves</em><br/><p>G and T for some debug dev mode shit, Y for fullscreen, P to pause</p>");
    body.append(fpscounter);
    body.append("<b>bindings:</b>");
    body.append(bindingsDOM);
    body.append("<b>settings:</b>");
    body.append(settingsDOM);
    mainloop();
    return requestAnimFrame(animate);
  };

  INIT();

  adjustmouseevent = function(e) {
    var adjusted, coffs;
    coffs = $(renderer.view).offset();
    adjusted = V(e.pageX - coffs.left, e.pageY - coffs.top);
    adjusted = adjusted.ndiv(scale);
    adjusted = adjusted.vadd(camera.pos);
    adjusted = adjusted.op(Math.round);
    return adjusted;
  };

  creatingblock = false;

  BLOCKCREATIONTOOL = {};

  BLOCKCREATIONTOOL.mousedown = function(e) {
    var adjusted;
    if (e.button !== 0) {
      return;
    }
    adjusted = adjustmouseevent(e);
    adjusted = snapmouseadjust(adjusted);
    creatingblock = new Block(adjusted.x, adjusted.y, 32, 32);
    return bglayer.push(creatingblock);
  };

  BLOCKCREATIONTOOL.mouseup = function(e) {
    return creatingblock = false;
  };

  snapmouseadjust = function(mpos) {
    var gridsize, snaptogrid;
    snaptogrid = isholdingkey('z');
    if (snaptogrid) {
      gridsize = 32;
      mpos = mpos.ndiv(gridsize).op(Math.floor).nmul(gridsize);
    }
    return mpos;
  };

  $(renderer.view).mousedown(BLOCKCREATIONTOOL.mousedown);

  $(renderer.view).mouseup(BLOCKCREATIONTOOL.mouseup);

  ORIGCLICKPOS = false;

  mousemiddledownhandler = function(e) {
    if (e.button !== 1) {
      return;
    }
    e.preventDefault();
    return ORIGCLICKPOS = V(e.pageX, e.pageY);
  };

  mousemiddleuphandler = function(e) {
    if (e.button !== 1) {
      return;
    }
    ORIGCLICKPOS = false;
    return camera.offset = V();
  };

  mousemovehandler = function(e) {
    var currclickpos, mpos, offset;
    mpos = snapmouseadjust(adjustmouseevent(e));
    if (creatingblock) {
      creatingblock.w = mpos.x - creatingblock.x;
      creatingblock.h = mpos.y - creatingblock.y;
      stage.removeChild(creatingblock._pixisprite);
      creatingblock._pixisprite = void 0;
    }
    if (ORIGCLICKPOS) {
      currclickpos = V(e.pageX, e.pageY);
      offset = currclickpos.vsub(ORIGCLICKPOS);
      camera.offset = offset;
      return console.log(offset);
    }
  };

  $(renderer.view).mousemove(mousemovehandler);

  $(renderer.view).mousedown(mousemiddledownhandler);

  $(renderer.view).mouseup(mousemiddleuphandler);

  mouserightdownhandler = function(e) {
    var adjusted, blox, ent;
    if (e.button !== 2) {
      return;
    }
    e.preventDefault();
    adjusted = adjustmouseevent(e);
    blox = blocksatpoint(bglayer, adjusted);
    console.log(blox);
    if (blox.length > 0) {
      ent = blox[0];
      bglayer = arrsansval(bglayer, ent);
      WORLD.bglayer = bglayer;
      return stage.removeChild(ent._pixisprite);
    }
  };

  $(renderer.view).mousedown(mouserightdownhandler);

  $(renderer.view).contextmenu(function() {
    return false;
  });

  $(renderer.view).bind('wheel', function(e) {
    var delta;
    e.preventDefault();
    delta = e.originalEvent.deltaY;
    up = delta > 0;
    console.log(delta);
    if (up) {
      scale -= 0.1;
    }
    if (!up) {
      return scale += 0.1;
    }
  });

}).call(this);
