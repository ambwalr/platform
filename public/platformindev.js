// Generated by CoffeeScript 1.6.3
(function() {
  var Block, BoggleParticle, BugLady, ControlObj, GenericSprite, Layer, Sprite, Target, V, V2d, ZEROVEC, add, arrclone, arrsansval, availableactions, avg, bglayer, body, boggle, boggletitles, bogimg, bottomof, brickcanvas, brickctx, cachedimg, cacheflippedimg, canvas, checkcolls, chievs, control, ctx, down, drawcolls, drawoutline, drawsprites, fallbox, falltitles, fglayer, flipimg, fpscounter, hitboxfilter, isholdingkey, ladybug, left, leftof, loadimg, logtimecall, looptick, mainloop, makechievbox, memoize, normalizekey, placeshrub, preload, preloadcontainer, randelem, randfloat, randint, randvec, rectsoverlap, render, right, rightof, skipframes, slowmo, somanygrafics, sourcebaseurl, sources, spritelayer, sum, tickno, ticktimes, tickwaitms, tilebackground, tilebackgroundobj, timecall, tmpcanvas, tmpcanvasjq, tmpctx, topof, tt, up, vadd, vdist, vmul, vnadd, vnmul, vsub, xmlatts, xmltag,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  slowmo = false;

  canvas = $("<canvas>");

  body = $("body");

  sourcebaseurl = "./sprites/";

  chievs = {};

  xmlatts = function(atts) {
    var key, val;
    return ((function() {
      var _results;
      _results = [];
      for (key in atts) {
        if (!__hasProp.call(atts, key)) continue;
        val = atts[key];
        _results.push(" " + key + "=\"" + val + "\"");
      }
      return _results;
    })()).join();
  };

  xmltag = function(type, atts, body) {
    if (type == null) {
      type = "div";
    }
    if (atts == null) {
      atts = {};
    }
    if (body == null) {
      body = "";
    }
    return "<" + type + (xmlatts(atts)) + ">" + body + "</" + type + ">";
  };

  arrclone = function(arr) {
    return arr.slice(0);
  };

  arrsansval = function(arr, val) {
    var i, newarr, _ref;
    newarr = arrclone(arr);
    if (_ref = !val, __indexOf.call(arr, _ref) >= 0) {
      return newarr;
    }
    i = newarr.indexOf(val);
    newarr.splice(i, 1);
    return newarr;
  };

  add = function(a, b) {
    return a + b;
  };

  sum = function(arr) {
    return arr.reduce(add, 0);
  };

  avg = function(arr) {
    return sum(arr) / arr.length;
  };

  V2d = (function() {
    function V2d(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
    }

    return V2d;

  })();

  V = function(x, y) {
    return new V2d(x, y);
  };

  V2d.prototype.clone = function() {
    return V(this.x, this.y);
  };

  ZEROVEC = V();

  vadd = function(v, u) {
    return V(add(v.x, u.x), add(v.y, u.y));
  };

  vsub = function(v, u) {
    return V(v.x - u.x, v.y - u.y);
  };

  vmul = function(v, u) {
    return V(v.x * u.x, v.y * u.y);
  };

  vnmul = function(v, n) {
    return V(v.x * n, v.y * n);
  };

  vnadd = function(v, n) {
    return V(v.x + n, v.y + n);
  };

  vdist = function(v, u) {
    return vsub(v, u).mag();
  };

  V2d.prototype.vadd = function(v) {
    return vadd(this, v);
  };

  V2d.prototype.vsub = function(v) {
    return vsub(this, v);
  };

  V2d.prototype.vnmul = function(n) {
    return vnmul(this, n);
  };

  V2d.prototype.vnadd = function(n) {
    return vnadd(this, n);
  };

  V2d.prototype.vmul = function(u) {
    return vmul(this, u);
  };

  V2d.prototype.op = function(op) {
    return V(op(this.x), op(this.y));
  };

  V2d.prototype.mag = function() {
    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
  };

  V2d.prototype.ndiv = function(n) {
    return V(this.x / n, this.y / n);
  };

  V2d.prototype.norm = function() {
    return this.ndiv(this.mag());
  };

  randfloat = function() {
    return -1 + Math.random() * 2;
  };

  randvec = function() {
    return V(randfloat(), randfloat());
  };

  randint = function(max) {
    return Math.floor(Math.random() * max);
  };

  randelem = function(arr) {
    return arr[randint(arr.length)];
  };

  Sprite = (function() {
    function Sprite() {
      this.vel = V();
      this.pos = V();
    }

    Sprite.prototype.tick = function() {};

    return Sprite;

  })();

  makechievbox = function(src, text) {
    var chievbox, pic;
    chievbox = $("<div><span style='display: inline-block; margin-left: 16px'><b>ACHIEVEMENT UNLOCKED</b><br/>" + text + "</span></div>");
    chievbox.css('border-radius', '50px');
    chievbox.css('padding', '8px 32px 8px 8px');
    chievbox.css('background-color', '#333');
    chievbox.css('color', 'white');
    chievbox.css('font-family', 'sans-serif');
    chievbox.css('display', 'inline-block');
    chievbox.css('position', 'absolute');
    chievbox.css('top', '-100px');
    chievbox.css('left', '32px');
    chievbox.prepend(pic = $(xmltag('img', {
      src: sourcebaseurl + src
    })));
    pic.css('background-color', '#444');
    pic.css('float', 'left');
    pic.css('border', '2px solid white');
    pic.css('border-radius', '64px');
    body.append(chievbox);
    chievbox.animate({
      top: '32px'
    }).delay(4000);
    return chievbox.animate({
      top: '-100px'
    }, {
      queue: true
    }).delay(2000);
  };

  GenericSprite = (function() {
    function GenericSprite(pos, src) {
      this.pos = pos != null ? pos : V();
      this.src = src;
    }

    GenericSprite.prototype.render = function(ctx) {
      var img;
      img = cachedimg(this.src);
      return ctx.drawImage(img, this.pos.x, this.pos.y);
    };

    return GenericSprite;

  })();

  GenericSprite.prototype.gethitbox = function() {
    return new Block(this.pos.x, this.pos.y, 32, 32);
  };

  Target = (function(_super) {
    __extends(Target, _super);

    function Target(pos) {
      this.pos = pos;
      this.src = 'target.png';
      this.lifetime = -1;
      this.vel = V();
    }

    Target.prototype.collide = function(otherent) {
      if (otherent instanceof BoggleParticle) {
        this.vel = this.vel.vadd(otherent.vel.vnmul(1 / 8));
      }
      if ((otherent.attacktimeout != null) && otherent.attacktimeout > 0 && topof(otherent.gethitbox()) < topof(this.gethitbox())) {
        return this.gethitby(otherent);
      }
    };

    Target.prototype.gethitby = function(otherent) {
      if (this.src !== 'shatteredtarget.png') {
        this.src = 'shatteredtarget.png';
        this.vel = otherent.vel.vnmul(1 / 2);
        return this.lifetime = 10;
      }
    };

    Target.prototype.render = function(ctx) {
      var img;
      img = cachedimg(this.src);
      return ctx.drawImage(img, this.pos.x, this.pos.y);
    };

    return Target;

  })(GenericSprite);

  GenericSprite.prototype.gethitbox = function() {
    var img;
    img = cachedimg(this.src);
    return new Block(this.pos.x, this.pos.y, img.naturalWidth, img.naturalHeight);
  };

  BoggleParticle = (function(_super) {
    __extends(BoggleParticle, _super);

    function BoggleParticle(pos) {
      this.pos = pos != null ? pos : V();
      this.pos = this.pos.vnadd(-8);
      this.pos.y += 16;
      this.vel = randvec().norm();
      this.src = 'huh.png';
      this.life = 50;
    }

    BoggleParticle.prototype.tick = function() {
      this.life -= 1;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = vadd(this.pos, this.vel);
      this.vel = vadd(this.vel, randvec().norm().ndiv(8));
      return checkcolls(this, spritelayer);
    };

    return BoggleParticle;

  })(GenericSprite);

  Target.prototype.tick = function() {
    this.vel = this.vel || V(0, 0);
    this.vel = this.vel.vnmul(7 / 10);
    this.pos = vadd(this.pos, this.vel);
    if (this.lifetime === 0) {
      this.KILLME = true;
    }
    if (this.lifetime > 0) {
      return this.lifetime--;
    }
  };

  isholdingkey = function(key) {
    key = key.toUpperCase().charCodeAt(0);
    return __indexOf.call(control.heldkeys, key) >= 0;
  };

  BugLady = (function(_super) {
    __extends(BugLady, _super);

    function BugLady() {
      BugLady.__super__.constructor.apply(this, arguments);
      this.jumping = false;
      this.attacking = false;
      this.attacktimeout = 0;
      this.stuntimeout = 0;
    }

    return BugLady;

  })(Sprite);

  BugLady.prototype.tick = function() {
    var boggling, box, candidates, ded, heading, lbw, spriteheight, vel, vellimit, walking, width;
    this.holdingboggle = isholdingkey('x');
    if (this.pos.y > 640) {
      if (!ded) {
        body.prepend("<p><b>YOU'RE DEAD</b> now don't let me catch you doing that again young lady</p>");
        ded = true;
      }
      this.pos = V();
      this.vel = V();
    }
    if (this.attacktimeout > 0 && this.touchingground()) {
      this.attacktimeout = 0;
    }
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    boggling = !walking && this.touchingground() && this.holdingboggle;
    if (boggling && Math.random() < 0.3) {
      spritelayer.push(new BoggleParticle(ladybug.pos.vnadd(32)));
    }
    if (this.stuntimeout > 0) {
      if (chievs.fall == null) {
        chievs.fall = true;
        makechievbox("lovelyfall.png", randelem(falltitles));
      }
      this.vel.x = 0;
      this.vel.y = 0;
      this.stuntimeout -= 1;
    }
    vellimit = this.touchingground() ? 4 : 5;
    if (this.vel.x > vellimit) {
      this.vel.x = vellimit;
    }
    if (this.vel.x < -vellimit) {
      this.vel.x = -vellimit;
    }
    spriteheight = 64;
    box = fallbox(this);
    candidates = hitboxfilter(box, bglayer);
    if (candidates.length > 0 && this.vel.y >= 0) {
      if (this.vel.y > 20) {
        this.stuntimeout = 20;
      }
      this.pos.y = candidates[0].y - spriteheight;
      this.vel.y = 0;
    }
    if (candidates.length > 0 && this.vel.y < 0) {
      this.vel.y = 0;
    } else {

    }
    this.attacking = this.attacktimeout > 0;
    heading = this.facingleft ? -1 : 1;
    if (this.attacking) {
      this.vel.y *= 0.7;
      this.attacktimeout -= 1;
      this.vel.x += heading * 0.3;
    }
    this.pos = vadd(this.pos, this.vel);
    if (!this.touchingground()) {
      this.vel.y += 1;
    }
    if (this.touchingground()) {
      this.vel.x = this.vel.x * 0.5;
      if (Math.abs(this.vel.x) < 0.0001) {
        this.vel.x = 0;
      }
    }
    if (this.touchingground() && this.jumping) {
      this.vel.y = -13;
    }
    this.jumping = false;
    lbw = 32;
    width = 640 + lbw;
    return this.avoidwalls();
  };

  bogimg = xmltag('img', {
    src: sourcebaseurl + 'boggle.png'
  });

  falltitles = ["Fractured spine", "Faceplant", "Dats gotta hoit", "OW FUCK", "pomf =3", "Broken legs", "Have a nice trip", "Ow my organs", "Shattered pelvis", "Bugsplat"];

  boggletitles = ["Buggy the boggle champ", "Bushboggler 2013", "Boggle that bush", "Collosal waste of time", "Boggle 2: Electric boggleoo", "Buggy bushboggle", "excuse me wtf are you doing", "Bush it, bush it real good", "Fondly regard flora", "&lt;chievo title unavailable due to trademark infringement&gt;", "Returning a bug to its natural habitat", "Bush it to the limit", "Live Free or Boggle Hard", "Identifying bushes, accurate results with simple tools", "Bugtester", "A proper lady (bug)", "Stupid achievement title", "The daily boggle", bogimg + bogimg + bogimg];

  boggle = function() {
    var boxes, cand, hit;
    if (chievs.boggle != null) {
      return;
    }
    hit = ladybug.gethitbox();
    boxes = fglayer.map(function(obj) {
      return obj.gethitbox();
    });
    cand = hitboxfilter(hit, boxes);
    if (cand.length > 0) {
      chievs.boggle = true;
      return makechievbox('boggle.png', randelem(boggletitles));
    }
  };

  BugLady.prototype.render = function(ctx) {
    var img, offsety, src, vel, walking;
    offsety = 3;
    src = "lovelyshorter.png";
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    if (walking) {
      src = tickno % 12 > 6 ? 'lovelyrun1.png' : 'lovelyrun2.png';
    }
    if (!this.touchingground()) {
      src = this.vel.y < 0 ? 'lovelyjump.png' : 'lovelycrouch.png';
    }
    if (!walking && isholdingkey('s')) {
      src = 'lovelycrouch.png';
    }
    if (!walking && this.touchingground() && this.holdingboggle) {
      boggle();
      src = 'boggle.png';
    }
    if (this.attacking) {
      src = 'viewtiful.png';
    }
    if (this.stuntimeout > 0) {
      src = 'lovelycrouch.png';
    }
    if (this.stuntimeout > 4) {
      src = 'lovelyfall.png';
      offsety = 6;
    }
    img = this.facingleft ? cacheflippedimg(src) : cachedimg(src);
    return ctx.drawImage(img, this.pos.x, this.pos.y + offsety);
  };

  hitboxfilter = function(hitbox, rectarray) {
    return rectarray.filter(function(box) {
      return rectsoverlap(hitbox, box);
    });
  };

  rectsoverlap = function(recta, rectb) {
    if (recta.x > rectb.x + rectb.w || recta.y > rectb.y + rectb.h || recta.x + recta.w < rectb.x || recta.y + recta.h < rectb.y) {
      return false;
    } else {
      return true;
    }
  };

  BugLady.prototype.gethitbox = function() {
    var h, offsety, trueh, w;
    trueh = 64;
    offsety = -4;
    h = 50;
    w = 20 + Math.abs(this.vel.x);
    return new Block(this.pos.x + (64 / 2 - w / 2), this.pos.y + (trueh - h), w, h);
  };

  fallbox = function(bug) {
    var box;
    box = bug.gethitbox();
    box.y += bug.vel.y;
    return box;
  };

  ladybug = new BugLady;

  ladybug.facingleft = false;

  ladybug.jumping = false;

  leftof = function(box) {
    return box.x;
  };

  rightof = function(box) {
    return box.x + box.w;
  };

  bottomof = function(box) {
    return box.y + box.h;
  };

  topof = function(box) {
    return box.y;
  };

  BugLady.prototype.avoidwalls = function() {
    var block, blockcandidates, collidebox, notontop, _i, _len, _results;
    collidebox = ladybug.gethitbox();
    blockcandidates = hitboxfilter(collidebox, bglayer);
    _results = [];
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      notontop = bottomof(collidebox) > topof(block) + 8;
      if (notontop && leftof(collidebox) < leftof(block)) {
        this.vel.x = 0;
        this.pos.x -= 4;
      }
      if (notontop && rightof(collidebox) > rightof(block)) {
        this.vel.x = 0;
        _results.push(this.pos.x += 4);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  BugLady.prototype.touchingground = function() {
    var block, blockcandidates, collidebox, touch, _i, _len;
    touch = false;
    collidebox = ladybug.gethitbox();
    blockcandidates = bglayer.filter(function(block) {
      return rectsoverlap(collidebox, block);
    });
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      if (collidebox.y + collidebox.h < block.y + block.h) {
        touch = true;
      }
    }
    return touch;
  };

  ControlObj = (function() {
    function ControlObj() {
      this.bindings = {};
      this.holdbindings = {};
      this.heldkeys = [];
    }

    return ControlObj;

  })();

  control = new ControlObj;

  control.bindings = {};

  control.holdbindings = {};

  control.heldkeys = [];

  normalizekey = function(key) {
    return key.toUpperCase().charCodeAt(0);
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return control.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keyholdbind = function(key, func) {
    return control.holdbindings[normalizekey(key)] = func;
  };

  control.keytapbind('t', function() {
    return slowmo = !slowmo;
  });

  somanygrafics = true;

  drawsprites = true;

  control.keytapbind('g', function() {
    return somanygrafics = !somanygrafics;
  });

  control.keytapbind('b', function() {
    return drawsprites = !drawsprites;
  });

  control.keytapbind('j', function() {
    return ladybug.jumping = true;
  });

  control.keyholdbind('j', function() {
    return ladybug.attacktimeout = 10;
  });

  up = function() {
    return ladybug.jumping = true;
  };

  down = function() {};

  left = function() {
    var amt;
    ladybug.facingleft = true;
    amt = ladybug.touchingground() ? 3 : 1;
    return ladybug.vel.x -= amt;
  };

  right = function() {
    var amt;
    ladybug.facingleft = false;
    amt = ladybug.touchingground() ? 3 : 1;
    return ladybug.vel.x += amt;
  };

  availableactions = [up, down, left, right];

  control.keyholdbind('w', up);

  control.keyholdbind('s', down);

  control.keyholdbind('a', left);

  control.keyholdbind('d', right);

  this.CONTROL = control;

  $(document).bind('keydown', function(e) {
    var key, _base;
    key = e.which;
    if (typeof (_base = control.bindings)[key] === "function") {
      _base[key]();
    }
    if (!(__indexOf.call(control.heldkeys, key) >= 0)) {
      return control.heldkeys.push(key);
    }
  });

  $(document).bind('keyup', function(e) {
    var key;
    key = e.which;
    return control.heldkeys = arrsansval(control.heldkeys, key);
  });

  tmpcanvasjq = $("<canvas>");

  tmpcanvas = tmpcanvasjq[0];

  ladybug.pos = V(64, 100);

  ctx = canvas[0].getContext('2d');

  canvas.attr('height', 64 * 6);

  canvas.attr('width', 640);

  canvas.css('border', '1px solid black');

  tickno = 0;

  loadimg = function(src) {
    var img;
    img = new Image;
    img.src = sourcebaseurl + src;
    return img;
  };

  memoize = function(func) {
    var newfunc;
    newfunc = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!(args in newfunc._memos)) {
        newfunc._memos[args] = func.apply(this, args);
      }
      return newfunc._memos[args];
    };
    newfunc._memos = {};
    return newfunc;
  };

  cachedimg = memoize(loadimg);

  flipimg = function(src) {
    var img, newcanvas, newctx;
    img = cachedimg(src);
    newcanvas = $("<canvas>")[0];
    newcanvas.width = img.naturalWidth;
    newcanvas.height = img.naturalHeight;
    newctx = newcanvas.getContext('2d');
    newctx.scale(-1, 1);
    newctx.translate(-img.naturalWidth, 0);
    newctx.drawImage(img, 0, 0);
    return newcanvas;
  };

  cacheflippedimg = memoize(flipimg);

  sources = ['lovelyshorter.png', 'lovelycrouch.png', 'lovelyrun1.png', 'lovelyrun2.png', 'lovelyjump.png', 'cloud.png', 'lovelyfall.png', 'viewtiful.png', 'boggle.png'];

  sources.push('groundtile.png');

  preloadcontainer = $("<div>");

  preloadcontainer.hide();

  body.append(preloadcontainer);

  preload = function() {
    var img, src, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      src = sources[_i];
      console.log("PRELOADING " + src);
      img = cachedimg(src);
      _results.push(preloadcontainer.append(img));
    }
    return _results;
  };

  preload();

  tilebackgroundobj = function(ctx, offset, imgobj) {
    var ch, cw, horiznum, img, vertnum, _i, _ref, _results;
    offset = offset.op(Math.round);
    cw = canvas[0].width;
    ch = canvas[0].height;
    img = imgobj;
    if (img.width === 0 || img.height === 0) {
      return;
    }
    horiznum = Math.floor(cw / img.width);
    vertnum = Math.floor(ch / img.height);
    return (function() {
      _results = [];
      for (var _i = -1, _ref = horiznum + 1; -1 <= _ref ? _i < _ref : _i > _ref; -1 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).forEach(function(n) {
      var _i, _ref, _results;
      return (function() {
        _results = [];
        for (var _i = -1, _ref = vertnum + 1; -1 <= _ref ? _i <= _ref : _i >= _ref; -1 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).forEach(function(m) {
        var finalx, finaly;
        finalx = n * img.width + (offset.x % img.width);
        finaly = m * img.height + (offset.y % img.height);
        return ctx.drawImage(img, finalx, finaly);
      });
    });
  };

  tilebackground = function(ctx, offset, src) {
    return tilebackgroundobj(ctx, offset, cachedimg(src));
  };

  Block = (function() {
    function Block(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }

    Block.prototype.render = function(ctx) {
      ctx.beginPath();
      ctx.fillStyle = 'brown';
      return ctx.fillRect(this.x, this.y, this.w, this.h);
    };

    return Block;

  })();

  tmpcanvas.width = canvas[0].width;

  tmpcanvas.height = canvas[0].height;

  tmpctx = tmpcanvas.getContext('2d');

  bglayer = [];

  bglayer.push(new Block(-64, 64 * 5 - 4, 64 * 12, 100));

  bglayer.push(new Block(64 * 4, 64 * 2, 32, 32));

  bglayer.push(new Block(64 * 5, 64 * 4, 32, 32));

  bglayer.push(new Block(64 * 6, 64 * 3, 32, 32));

  bglayer.push(new Block(32, 64 * 4, 64 * 2, 64 * 2));

  bglayer.push(new Block(64 * 12, 64 * 4, 64 * 12, 200));

  fglayer = [];

  spritelayer = [];

  spritelayer = spritelayer.concat([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(function() {
    return new Target(V(640 * 1.5, 64 * 2).vadd(randvec().vmul(V(640, 100))));
  }));

  placeshrub = function(pos) {
    pos = vsub(pos, V(0, 32));
    return fglayer.push(new GenericSprite(pos, 'shrub.png'));
  };

  placeshrub(V(64 * 8, 64 * 5 - 4));

  placeshrub(V(64 * 7 - 48, 64 * 5 - 4));

  Layer = function() {
    var newlayer;
    newlayer = $("<canvas>");
    return newlayer[0];
  };

  brickcanvas = Layer();

  brickcanvas.width = canvas[0].width;

  brickcanvas.height = canvas[0].height;

  brickctx = brickcanvas.getContext('2d');

  drawoutline = function(ctx, block, color) {
    ctx.beginPath();
    ctx.rect(block.x, block.y, block.w, block.h);
    ctx.lineWidth = 1;
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  drawcolls = function(ctx) {
    var collidebox, findhitboxesof, hitboxes, hits;
    collidebox = ladybug.gethitbox();
    drawoutline(ctx, collidebox, 'blue');
    collidebox = fallbox(ladybug);
    drawoutline(ctx, collidebox, 'orange');
    findhitboxesof = [].concat(spritelayer, fglayer);
    hits = findhitboxesof.map(function(sprite) {
      return sprite.gethitbox();
    });
    hitboxes = [].concat(bglayer, hits);
    return hitboxes.forEach(function(block) {
      var color;
      color = rectsoverlap(collidebox, block) ? 'red' : 'green';
      return drawoutline(ctx, block, color);
    });
  };

  render = function() {
    var cw, offs, renderables;
    ctx.fillStyle = "skyblue";
    ctx.save();
    ctx.fillRect(0, 0, 640, 640);
    if (somanygrafics) {
      tilebackground(ctx, V(tickno * -0.2, Math.sin(tickno / 200) * 64), "cloud.png");
    }
    cw = 640;
    offs = -(ladybug.pos.x - cw / 2);
    ctx.translate(offs, 0);
    if (drawsprites) {
      tilebackground(brickctx, V(), "groundtile.png");
    }
    tmpctx.clearRect(0, 0, 640, 640);
    bglayer.forEach(function(sprite) {
      return typeof sprite.render === "function" ? sprite.render(ctx) : void 0;
    });
    bglayer.forEach(function(sprite) {
      return typeof sprite.render === "function" ? sprite.render(tmpctx) : void 0;
    });
    tmpctx.globalCompositeOperation = "source-in";
    tmpctx.drawImage(brickcanvas, 0, 0);
    tmpctx.globalCompositeOperation = "source-over";
    ctx.drawImage(tmpcanvas, 0, 0);
    if (!somanygrafics) {
      drawcolls(ctx);
    }
    renderables = [].concat(spritelayer, [ladybug], fglayer);
    if (drawsprites) {
      renderables.forEach(function(sprite) {
        return typeof sprite.render === "function" ? sprite.render(ctx) : void 0;
      });
    } else {
      renderables.forEach(function(sprite) {
        var hb;
        hb = sprite.gethitbox();
        offs = 0.5;
        hb.x = offs + Math.round(hb.x);
        hb.y = offs + Math.round(hb.y);
        hb.w = Math.round(hb.w) - offs * 2;
        hb.h = +Math.round(hb.h) - offs * 2;
        return drawoutline(ctx, hb, 'black');
      });
    }
    return ctx.restore();
  };

  timecall = function(func) {
    var starttime;
    starttime = Date.now();
    func();
    return Date.now() - starttime;
  };

  logtimecall = function(func) {
    return console.log("" + (timecall(func)) + " ms.");
  };

  body.append(fpscounter = $(xmltag()));

  tickwaitms = 20;

  skipframes = 0;

  ticktimes = [];

  checkcolls = function(ent, otherents) {
    var bawks;
    bawks = ent.gethitbox();
    return otherents.forEach(function(target) {
      var targethitbox;
      if (target === ent) {
        return;
      }
      targethitbox = target.gethitbox();
      if (rectsoverlap(bawks, targethitbox)) {
        return typeof target.collide === "function" ? target.collide(ent) : void 0;
      }
    });
  };

  looptick = function() {
    var doomedsprites, key, _base, _i, _len, _ref;
    _ref = control.heldkeys;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (typeof (_base = control.holdbindings)[key] === "function") {
        _base[key]();
      }
    }
    checkcolls(ladybug, spritelayer);
    doomedsprites = spritelayer.filter(function(sprite) {
      return sprite.KILLME != null;
    });
    doomedsprites.forEach(function(sprite) {
      return spritelayer = arrsansval(spritelayer, sprite);
    });
    spritelayer.forEach(function(sprite) {
      return typeof sprite.tick === "function" ? sprite.tick() : void 0;
    });
    ladybug.tick();
    if (skipframes === 0 || tickno % (skipframes + 1) === 0) {
      render();
    }
    return tickno++;
  };

  tt = 0;

  mainloop = function() {
    var fps, idealfps, ticktime;
    ticktime = timecall(looptick);
    ticktimes.push(ticktime);
    if (ticktimes.length > 16) {
      tt = Math.round(avg(ticktimes));
      ticktimes = [];
      skipframes = Math.floor(tt / tickwaitms);
    }
    fps = Math.round(1000 / Math.max(tickwaitms, ticktime));
    idealfps = Math.round(1000 / tickwaitms);
    fpscounter.html("avg tick time: " + tt + "ms, skipping " + skipframes + " frames, running at approx " + fps + " fps (aiming for " + idealfps + " fps)");
    tickwaitms = slowmo ? 1000 / 4 : 1000 / 60;
    return setTimeout(mainloop, Math.max(tickwaitms - ticktime, 1));
  };

  preloadcontainer.imagesLoaded('done', function() {
    body.append("<br/><em>there's no crime to fight around here, use WASD to waste time by purposelessly wiggling around,<br/>X to boggle vacantly and J to do some wicked sick totally radical moves</em><br/><p>G and T for some debug dev mode shit</p>");
    return mainloop();
  });

  body.append(canvas);

  canvas.mousedown(function(e) {
    var adjusted, coffs;
    coffs = $(canvas).offset();
    adjusted = V(e.pageX - coffs.left, e.pageY - coffs.top);
    return bglayer.push(new Block(Math.round(-320 + adjusted.x + ladybug.pos.x), adjusted.y, 32, 32));
  });

}).call(this);
